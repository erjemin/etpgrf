# tests/test_hyphenation.py
import pytest
from etpgrf import Hyphenator

# --- Тестовые данные для русского языка ---
# Формат: (входное_слово, ожидаемый_результат_с_переносами)
# Используем \u00AD - это Unicode-представление мягкого переноса (&shy;)
RUSSIAN_HYPHENATION_CASES = [
    ("дом", "дом"),  # Сочень короткое (короче max_unhyphenated_len) не должно меняться
    ("проверка", "проверка"),  # Короткое слово не должно меняться
    ("тестирование", "тести\u00ADрование"),
    ("благотворительностью", "благотво\u00ADритель\u00ADностью"), # Слово с переносом на мягкий знак
    ("гиперподъездной", "гипер\u00ADподъ\u00ADездной"),  # Слово с переносом на твердый знак
    ("фотоаппаратура", "фотоап\u00ADпара\u00ADтура"), # проверка слова с двойной согласной
    ("сверхзвуковой", "сверхзву\u00ADковой"),
    ("автомобиль", "авто\u00ADмобиль"),  # Слово с переносом на мягкий знак
    ("интернационализация", "интерна\u00ADциона\u00ADлизация"),  # Длинное слово с переносами
    ("программирование", "програм\u00ADмиро\u00ADвание"),
    ("суперкомпьютер", "супер\u00ADком\u00ADпьютер"),
    ("электронный", "электрон\u00ADный"),
    ("информационный", "информа\u00ADционный"),
    ("автоматизация", "авто\u00ADмати\u00ADзация"),
    ("многоклеточный", "многок\u00ADлеточ\u00ADный"),  # Сложное слово с переносами
    ("многофункциональный", "многофун\u00ADкцио\u00ADнальный"),  # Сложное слово с переносами
    ("непрерывность", "непре\u00ADрывность"),  # Слово с мягким знаком в конце
    ("сверхпроводимость", "сверхпро\u00ADводи\u00ADмость"),  # Слово с мягким знаком в середине
]


@pytest.mark.parametrize("input_word, expected_output", RUSSIAN_HYPHENATION_CASES)
def test_russian_word_hyphenation(input_word, expected_output):
    """
    Проверяет ПОВЕДЕНИЕ: правильная расстановка переносов в отдельных русских словах.
    """
    # Arrange (подготовка)
    hyphenator_ru = Hyphenator(langs='ru', max_unhyphenated_len=5, min_tail_len=3)
    # Act (действие) - тестируем самый "атомарный" метод
    actual_output = hyphenator_ru.hyp_in_word(input_word)
    # Assert (проверка)
    assert actual_output == expected_output



